server {
  listen 80;
  server_name _;

  root /usr/share/nginx/html/public;
  index index.html;

  # Resolve Docker service names at request-time so gateway can start even
  # when optional auth backend container is not up yet.
  resolver 127.0.0.11 ipv6=off valid=30s;
  set $authelia_upstream authelia:9091;

  location = /healthz {
    access_log off;
    add_header Content-Type text/plain;
    return 200 'ok';
  }

  # Authelia portal (Iteration 5)
  location /auth/ {
    proxy_intercept_errors on;
    error_page 502 503 504 = @auth_unavailable;
    proxy_pass http://$authelia_upstream;
    proxy_set_header Host $host;
    proxy_set_header X-Original-URL $scheme://$http_host$request_uri;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Uri $request_uri;
    proxy_set_header X-Real-IP $remote_addr;
  }

  location = /internal/authelia/authz {
    internal;
    proxy_intercept_errors on;
    error_page 502 503 504 = @auth_unavailable;
    proxy_pass http://$authelia_upstream/auth/api/authz/auth-request;
    proxy_set_header Host $host;
    proxy_set_header Content-Length "";
    proxy_set_header X-Original-URL $scheme://$http_host$request_uri;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Uri $request_uri;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass_request_body off;
  }

  location @auth_unavailable {
    add_header Content-Type text/plain;
    return 503 "auth backend unavailable; check authelia container and secrets";
  }

  # Public surface (strict static files, no silent fallback to home)
  location / {
    set $clean_uri $uri;
    if ($clean_uri ~ "^(.+)/$") { set $clean_uri $1; }
    try_files $clean_uri $clean_uri/ $clean_uri/index.html =404;
  }

  # Explicit pretty-url routes for section MOCs
  location = /politik { return 301 /politik/; }
  location = /politik/ { try_files /politik/index.html =404; }

  location = /technik { return 301 /technik/; }
  location = /technik/ { try_files /technik/index.html =404; }

  location = /reisen { return 301 /reisen/; }
  location = /reisen/ { try_files /reisen/index.html =404; }

  location = /politik/dossier-iran { return 301 /politik/dossier-iran/; }
  location = /politik/dossier-iran/ { try_files /politik/dossier-iran/index.html =404; }

  # Private output (Iteration 5: auth protected)
  location /private/ {
    auth_request /internal/authelia/authz;
    auth_request_set $auth_user $upstream_http_remote_user;
    error_page 401 =302 /auth/?rd=$scheme://$http_host$request_uri;

    rewrite ^/private/?(.*)$ /$1 break;
    set $clean_uri $uri;
    if ($clean_uri ~ "^(.+)/$") { set $clean_uri $1; }
    alias /usr/share/nginx/html/private/;
    add_header X-Robots-Tag "noindex, nofollow" always;
    add_header X-Authenticated-User $auth_user always;
    try_files $clean_uri $clean_uri/ $clean_uri/index.html =404;
  }

  location /g/friends/ {
    auth_request /internal/authelia/authz;
    auth_request_set $auth_user $upstream_http_remote_user;
    auth_request_set $auth_groups $upstream_http_remote_groups;
    error_page 401 =302 /auth/?rd=$scheme://$http_host$request_uri;
    if ($auth_groups !~* "(^|[, ]+)friends([, ]+|$)") { return 403; }

    rewrite ^/g/friends/?(.*)$ /$1 break;
    set $clean_uri $uri;
    if ($clean_uri ~ "^(.+)/$") { set $clean_uri $1; }
    alias /usr/share/nginx/html/groups/friends/;
    add_header X-Robots-Tag "noindex, nofollow" always;
    add_header X-Authenticated-User $auth_user always;
    try_files $clean_uri $clean_uri/ $clean_uri/index.html =404;
  }

  location /g/family/ {
    auth_request /internal/authelia/authz;
    auth_request_set $auth_user $upstream_http_remote_user;
    auth_request_set $auth_groups $upstream_http_remote_groups;
    error_page 401 =302 /auth/?rd=$scheme://$http_host$request_uri;
    if ($auth_groups !~* "(^|[, ]+)family([, ]+|$)") { return 403; }

    rewrite ^/g/family/?(.*)$ /$1 break;
    set $clean_uri $uri;
    if ($clean_uri ~ "^(.+)/$") { set $clean_uri $1; }
    alias /usr/share/nginx/html/groups/family/;
    add_header X-Robots-Tag "noindex, nofollow" always;
    add_header X-Authenticated-User $auth_user always;
    try_files $clean_uri $clean_uri/ $clean_uri/index.html =404;
  }
}
